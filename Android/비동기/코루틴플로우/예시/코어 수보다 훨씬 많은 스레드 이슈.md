하드웨어에서 각 스레드는 프로세서의 코어를 사용하여 실행됩니다. 한번에 실행할 수 있는 스레드의 수는 대부분의 시스템에서 사용 가능한 코어 수에 의해 제한됩니다. 따라서, 코어 수보다 훨씬 많은 스레드를 생성하면,
다음과 같은 이슈가 발생할 수 있습니다:

### **문맥 교환 비용**:

스레드가 코어를 공유하게 되면, 운영체제는 하나의 스레드에서 다른 스레드로 전환할 때마다 문맥 교환(context switch)을 수행해야 합니다. 이는 현재 스레드의 상태를 저장하고, 새로운 스레드의 상태를
불러오는 과정을 포함하며, 이로 인해 상당한 오버헤드가 발생합니다. 스레드가 많을수록 더 많은 문맥 교환이 발생하므로, 이런 오버헤드는 증가합니다.

### **메모리 오버헤드**:

각 스레드는 고유한 스택 메모리를 필요로 합니다. 스레드가 많아질수록 이런 메모리 요구사항도 증가하며, 이는 시스템 메모리에 부담을 주고, 메모리 부족을 일으킬 수 있습니다.

### **동기화 복잡성**:

스레드가 많아질수록, 공유 리소스에 대한 동기화가 복잡해집니다. 락이나 세마포어 같은 동기화 메커니즘을 사용하여 여러 스레드가 동시에 같은 리소스에 접근하는 것을 방지해야 합니다. 이런
동기화 작업은 오버헤드를 발생시키며, 데드락 같은 문제를 유발할 수 있습니다. 따라서, 복잡한 연산을 수행하는 경우에도, 필요한 만큼의 스레드만을 생성하고, 코어 수를 초과하지 않도록 관리하는 것이 중요합니다.
이는 오버헤드를 줄이고, 시스템 자원을 효율적으로 활용하는 데 도움이 됩니다. 또한, 일부 경우에서는 스레드를 사용하는 것보다 병렬화를 통해 고성능을 얻는 것이 더 효과적일 수 있습니다. 예를 들어, GPU를
사용하는 경우나, 벡터화된 연산을 수행하는 경우 등입니다.