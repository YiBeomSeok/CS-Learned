# 채널

코루틴 간 데이터를 교환할 수 있다.

일종의 파이프와 비슷한데, 한 쪽에서 데이터를 넣고 다른 쪽에서 데이터를 받는 것이다.

코틀린 코루틴의 채널(Channel)은 Go 언어의 채널 개념과 비슷하게, 동시성 프로그래밍에서 사용되는 중요한 도구이다.

채널은 생산자(producer)와 소비자(consumer) 사이에서 데이터를 전달하는 안전한 방법을 제공한다.

## 채널의 기본 아이디어

1. 생산자(producer)는 채널에 요소를 전달하거나 보낸다. 이 작업은 `send` 메소드를 사용하여 수행된다.
2. 소비자(consumer)는 채널로부터 수신한다. 이 작업은 `receive` 메소드를 사용하여 수행된다.
3. 채널은 FIFO(First-In-First-Out) 순서로 요소를 처리한다. 즉, 먼저 전송된 요소가 먼저 수신된다.
4. 채널은 코루틴 간에 안전하게 데이터를 전달하는 역할을 한다.

## 생성

- `Channel()`: 무한 용량을 가지는 채널을 생성.
- `Channel(capacity: Int)`: 주어진 용량으로 채널을 생성.
- `ConflatedChannel()`: 최신의 값만 유지하는 채널을 생성.
- `RedezvousChannel()`: 수신자가 준비될 때까지 전송자가 대기하는 채널 생성.
- `BufferedChannel(capacity: Int)`: 주어진 용량으로 버퍼링된 채널을 생성.

코틀린의 채널은 동시성을 관리하는 복잡한 방법에 비해 훨씬 간단하고 직관적인 방법을 제공할 수 있다.

다만, 채널을 사용하면서 데이터가 정확하게 전달되고 순서가 유지되는 것을 보장해야하며, 또한 차단 없이 동시성을 처리할 수 있어야 한다.

## 채널 프로듀서

채널 프로듀서는 데이터를 생성하고 채널에 데이터를 전달하는 역할을 한다.

이러한 코틀린의 채널 프로듀서는 보통 `produce` 함수를 사용하여 생성된다.

`produce` 함수는 프로듀서 코루틴을 만들고, 이를 통해 데이터를 생성하고 채널로 보내는데, 보통 다른 코루틴에서 소비할 데이터를 생성하는데 사용된다.

```kotlin
val channel = GlobalScope.produce {
    for (x in 1..5) send(x * x)
}
```

이 코드에서 `produce` 함수는 1부터 5까지의 숫자를 제곱하고, 그 결과를 채널로 보내는 프로듀서 코루틴을 생성한다.

이렇게 생성된 채널은 다른 코루틴에서 `receive`나 `receiveOrNull` 함수를 사용하여 데이터를 받을 수 있다.

### 확장 함수

1. `produce`: 코루틴을 만들고 채널을 제공한다.
2. `consumeEach`: 채널에서 반복해서 데이터를 받아간다.

`ProducerScope`는 `CoroutineScope` 인터페이스와 `SendChannel` 인터페이스를 함께 상속받는다. 그래서 코루틴 컨텍스트와 몇가지 채널 인터페이스를 같이 사용할 수 있는 스코프이다.

### 참고

#### ProducerScope

이 인터페이스는 `CoroutineScope`와 `SendChannel`인터페이스를 상속받는다. 이것은 `ProducerScope`가 코루틴 컨텍스트와 채널 인터페이스를 동시에
제공한다는 것을 의미한다.

- `CoroutineScope`는 코루틴의 범위를 정의하며 코루틴 빌더 함수(ex: `launch`, `async`, `produce` 등)를 사용할 수 있는 `coroutineContext`를 제공한다.
- `SendChannel`은 데이터를 채널로 전송할 수 있는 메소드를 제공한다.

따라서 `ProducerScope` 내부에서는 코루틴 컨텍스트에 접근하고, 채널로 데이터를 보낼 수 있다.
이는 채널 프로듀서 내에서 특히 유용하게 사용된다.

#### runBlocking과 BlockingCoroutine

`runBlocking`은 주어진 블록 내에서 새로운 코루틴을 실행하고, 이 코루틴이 완료될 때까지 현재 스레드를 차단하는 함수이다.
이 함수는 `BlockingCoroutine` 인스턴스를 사용하는데, `AbstractCoroutine`을 상속받으며, `runBlocking` 함수의 동작을 구현하는데 필요한 추가 기능을 제공한다.

> `AbstractCoroutine`은 `JobSupport`, `Job`(인터페이스), `Continuation`(인터페이스), `CoroutineScope`(인터페이스)를 상속받고 있다.
>
> `Continuation`은 다음에 무엇을 할지, `Job`은 제어를 위한 정보와 제어(캔슬이나 조인 등), `CoroutineScope`는 컨텍스트 제공의 역할을 한다.
> `JobSupport`는 Job의 실무를 담당한다.

#### 코루틴 빌더가 코루틴 스코프

코루틴 빌더(ex: `launch`, `async`, `produce` 등)는 새로운 코루틴을 생성하고, 이 코루틴들은 자신이 생성된 스코프 내에서 실행된다. 즉, 코루틴 빌더는 코루틴을 생성하는 역할을 하며,
동시에 생성된 코루틴의 생명주기를 관리하는 코루틴 스코프의 역할도 한다.

이러한 구조는 코루틴의 생명주기를 효과적으로 관리하고, 필요한 경우 코루틴을 취소하거나 정지하는 데 도움이 된다.

## 채널 버퍼링

버퍼링은 채널의 한 가지 특징으로, 채널에 데이터를 "저장"할 수 있도록 한다. 버퍼링된 채널은 내부에 공간을 가지고 있어, 이 공간에 데이터를 넣을 수 있다. 이렇게 데이터를 저장해두면, 수신 코루틴이 준비되었을
때 바로 데이터를 전달할 수 있다.

버퍼링이 없는 채널(즉, 용량이 0인 채널)은 "런디버퍼(run-debuffer)"라고도 하며, 이 경우 데이터를 보낼 때 수신 코루틴이 준비된 상태가 아니라면 보내는 코루틴은 블로킹(Blocking) 상태가 된다.
반면, 버퍼링이 있는 채널은 버퍼에 공간이 있는 한 보내는 코루틴이 블로킹 상태에 빠지지 않을 수 있다.

버퍼의 크기는 Channel 생성자에 인수로 전달하여 설정할 수 있으며, 만약 인수를 전달하지 않는다면 기본적으로 런디버퍼 채널이 생성된다.