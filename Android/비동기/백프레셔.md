# 백프레셔(backpressure)

백프레셔는 비동기 프로그래밍에서 데이터의 생산자(producer)와 소비자(consumer) 사이의 속도 차이를 관리하는 메커니즘이나 전략이다.
생산자가 소비자보다 빠르게 데이터를 생성할 경우, 소비자는 처리할 수 있는 속도를 초과하여 데이터가 전달되는 것을 방지하기 위해 백프레셔를 사용한다.
이렇게 하면 시스템 전체의 안정성을 유지하고 자원을 효율적으로 사용할 수 있다.

## 주요 이점

1. 안정성: 생산자와 소비자 간의 속도 차이로 인한 과부하를 방지하고, 시스템 전체의 안정성을 유지한다.
2. 자원 효율성: 소비자가 처리할 수 있는 속도를 초과하는 데이터가 전달되지 않도록 하여, 메모리 사용량이 증가하거나 다른 자원이 낭비되는 것을 방지한다.
3. 흐름 제어: 소비자는 데이터 처리 속도를 조절할 수 있으며, 생산자에게 처리할 수 있는 데이터의 수량을 알려줄 수 있다. 이를 통해 생산자는 소비자가 처리할 수 있는 속도에 맞춰 데이터를 생성할 수 있다.

## 코루틴 플로우에서

코루틴 플로우는 생산자와 소비자 사이의 백프레셔를 자동으로 처리한다. Flow는 코루틴을 기반으로 하는 비동기 데이터 스트림 라이브러리로, 코루틴을 사용하여 데이터를 생성하고 전달하는 과정에서 백프레셔를 지원한다.

코루틴 플로우에서 백프레셔 처리는 다음과 같이 작동한다.

1. Flow 생성: 데이터를 비동기적으로 생성하는 `flow {...}` 빌더를 사용하여 Flow 인스턴스를 생성한다. 이 때, `emit()` 함수를 사용하여 데이터를 전달할 수 있다.
2. Flow 사용: Flow를 사용하는 측에서 `collect`, `map`, `filter` 등의 연산자를 사용하여 데이터를 처리한다. 이 때, 각 연산자는 코루틴으로 실행되며, 이를 통해 비동기적으로 데이터를
   처리할 수 있다.
3. 백프레셔 처리: 소비자가 데이터를 처리하는 동안 생산자는 자동으로 일시 중지된다. 즉, 소비자가 처리할 수 있는 속도보다 데이터가 빠르게 생성되지 않는다. 이를 통해 백프레셔가 자동으로 처리되며, 소비자의
   부하를 줄일 수 있다.
   코루틴 플로우는 코루틴의 일시 중지(suspend) 기능을 활용하여 백프레셔를 처리한다. Flow의 생산자 측에서는 `emit()` 함수가 일시 중지되어 소비자가 데이터를 처리하는 속도에 맞춰 데이터를
   전달한다. 이를 통해 생산자와 소비자 사이의 속도 차이를 관리하고, 시스템 전체의 안정성을 유지할 수 있다.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

suspend fun main() = coroutineScope {
    // Flow 생성
    val flow = flow {
        for (i in 1..5) {
            delay(100) // 데이터 생성에 시간이 걸리는 상황을 시뮬레이션
            println("Emitting $i")
            emit(i)
        }
    }

    // Flow 사용
    flow.collect { value ->
        // 소비자가 데이터를 처리하는 데 시간이 걸림을 가정
        delay(200)
        println("Received $value")
    }
}
```

`flow` 빌더를 사용하여 `Flow<Int>`를 생성한다. 그리고 1에서 5까지의 숫자를 생성하고, `delay(100)`을 사용하여 데이터 생성에 시간이 걸리는 상황을 시뮬레이션한다.

소비자 측에서는 `flow.collect`를 사용하여 Flow로부터 데이터를 수집하고 처리한다. 여기서 `delay(200)`을 사용하여 데이터 생성에 시간이 걸리는 상황을 시뮬레이션한다.

예제에서 생산자는 100ms마다 데이터를 생성하고, 소비자는 200ms마다 데이터를 처리한다. 코루틴 플로우는 이러한 상황에서 백프레셔를 자동으로 처리한다. 소비자가 데이터를 처리하는 동안 생산자는 일시 중지되어, 소비자의 처리 속도에 맞춰 데이터가 전달된다.

위 코드를 실행하면 다음의 결과가 출력될 수 있다.

```
Emitting 1
Received 1
Emitting 2
Received 2
Emitting 3
Received 3
Emitting 4
Received 4
Emitting 5
Received 5
```